
/**
 * Copyright (c) 2015-2016 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENCE file at the root of the project for the full licence.
 *
 * This parser borrows quite liberally from the awesome ES5Parser built by
 * Jonathan Brachth√§user (http://b-studios.de). But, don't worry this implements
 * a C grammar and not a JavaScript grammar as ES5!
 */


// Dependencies
var __      = require('../nodes.js');


/**
 * Reduced C: This parser accepts a subset of the C language.
 * I want to get the JAMScript up and running to hash out the many problems we
 * would encounter in deploying a 'bridge' language and understand what we could do
 * with it.
 *
 * Simplifications:
 * - no typedefs
 * - no complicated structures.. only primary types are included in structures
 * - only basic pointer patterns
 * - no suffix for constants like integers or floats
 * - no prefix for strings
 * - no structures
 * - no enums
 * - no abstract direct declarations
 * - need to check with the full C95 specification for other omissions
 */


var declattr = function() {
    return {
        storage_class: undefined,
        type_qual: undefined,
        type_spec: undefined
    }
};



ometa CParser  {

    // Helper Rules
    //
    isKeyword :x    = ?this.spec.isKeyword(x),
    nameFirst       = ^letter | '_',
    nameRest        = nameFirst | ^digit,
    linebreak       = '\n',


    // Comments
    //
    comment         = ``//'' (~linebreak char)* &linebreak
                    | fromTo('/*', '*/'),

    space           = ^space | comment | linebreak,
    spacesNoNl      = (~linebreak space)*,

    // Identifiers and Names
    //
    iName           = <nameFirst nameRest*>,
    id              = iName:name ~isKeyword(name)                   -> __.Id(name),
    keyword         = iName:kwd isKeyword(kwd)                      -> __.Keyword(kwd),

    // Numeric Literals
    //
    hexDigit        = ^digit | range('a', 'f') | range('A', 'F'),
    hex             = <``0x''|``0X'' hexDigit+>:d                   -> __.Number(parseInt(d)).kind('hex'),

    decimalInt      = '0' | (~'0' digit) digit*,
    expPart         = ('e' | 'E') ('+' | '-')? digit+,

    octal           = <'0' digit+>:d                                -> __.Number(parseInt(d,8)).kind('oct'),

    decimal         = <'-'? decimalInt ('.' digit+)? expPart?>:f    -> __.Number(f).kind('float')
                    | <'-'? ('.' digit+) expPart?>:f                -> __.Number(f).kind('float'),

    integer         = <'-'? decimalInt>:d                           -> __.Number(parseInt(d)).kind('int'),

    number          = hex | octal | decimal | integer,

    // String Literals
    //
    escapeChar      = <'\\' char>:c                                 -> unescape(c),

    string          = '"' (escapeChar | ~'"' char)*:cs '"'          -> __.String(cs.join(''))
                    | ('#' | '`') iName:n                           -> __.String(cs.join('')),

    // Punctuator symbols
    //
    punctuator         = ( ``...'' | ``>>='' | ``<<='' | ``+='' | ``-=''
                  | ``*='' | ``/='' | ``%='' | ``&='' | ``^=''
                  | ``|='' | ``>>'' | ``<<'' | ``++'' | ``--''
                  | ``->'' | ``&&'' | ``||'' | ``<='' | ``>=''
                  | ``=='' | ``!='' | ';' | '{' | '}' | ','
                  | ':' | '=' | '(' | ')' | '[' | ']' | '.'
                  | '&' | '!' | '~' | '-' | '+' | '*' | '/'
                  | '%' | '<' | '>' | '^' | '|' | '?' ):s           -> __.Punctuator(s),


    token :tt       = spaces ( ( punctuator | keyword ):t ?(t.value() == tt)        -> t
                    | (id | number | string):t ?(t[0] == tt)                        -> t
                    ),


    // Expressions
    //
    // TODO: arg_expr_list .. is it just an alias to expression?
    // FIXME: There could be a difference due to semantics..

    listof :p       = apply(p):x ("," apply(p))*:y                  -> {y.unshift(x); y},

    expr            =  listof(#assign_expr):le                      -> (le.length > 1? __.SequenceExpr(le) : le[0]),


    assign_expr     = unary_expr:lhs assign_op:op assign_expr:rhs   -> __.AssignExpr(lhs, rhs).operator(op.value())
                    | cond_expr,

    cond_expr       = lor_expr:e "?" expr:t ":" cond_expr:f         -> __.CondExpr(e, t, f)
                    | lor_expr,


    // Binary operations
    //
    lor_expr        = lor_expr:x "||" lar_expr:y                    -> __.BinaryExpr(x, y).operator("||")
                    | lar_expr,
    lar_expr        = lar_expr:x "&&" ior_expr:y                    -> __.BinaryExpr(x, y).operator("&&")
                    | ior_expr,
    ior_expr        = ior_expr:x "|" xor_expr:y                     -> __.BinaryExpr(x, y).operator("|")
                    | xor_expr,
    xor_expr        = xor_expr:x "^" and_expr:y                     -> __.BinaryExpr(x, y).operator("^")
                    | and_expr,
    and_expr        = and_expr:x "&" eq_expr:y                      -> __.BinaryExpr(x, y).operator("&")
                    | eq_expr,
    eq_expr         = eq_expr:x ( "==" | "!=" ):op rel_expr:y       -> __.BinaryExpr(x, y).operator(op.value())
                    | rel_expr,
    rel_expr        = rel_expr:x ( "<=" | "<"
                                    | ">=" | ">"):op shift_expr:y   -> __.BinaryExpr(x, y).operator(op.value())
                    | shift_expr,
    shift_expr      = shift_expr:x ( "<<" | ">>" ):op add_expr:y    -> __.BinaryExpr(x, y).operator(op.value())
                    | add_expr,
    add_expr        = add_expr:x ( "+" | "-" ):op mult_expr:y          -> __.BinaryExpr(x, y).operator(op.value())
                    | mult_expr,
    mult_expr       = mult_expr:x ( "*" | "/" | "%" ):op prefix_expr:y -> __.BinaryExpr(x, y).operator(op.value())
                    | prefix_expr,

    assign_op       = "=" | "*=" | "/=" | ">>=" | "<<=" | "+=" | "-="
                    | "%=" | "&=" | "|=" | "^=",


    // Unary operators
    //

    //
    prefix_expr     = ( "++" | "--" ):op spacesNoNl unary_expr:e    -> __.UpdateExpr(e).operator(op.value())
                    | unary_expr,

    //
    unary_expr      = ( "&" | "*" | "+" | "-"
                            | "~" | "!" ):op prefix_expr:e          -> __.UnaryExpr(e).operator(op.value())
                    | "sizeof" unary_expr:e
                    | postfix_expr,

    postfix_expr    = left_expr:e spacesNoNl ( "++" | "--" ):op     -> __.UpdateExpr(e).operator(op.value()).prefix(false)
                    | left_expr,

    left_expr       = left_expr:p call_expr(p)
                    | left_expr:p member_expr(p)
                    | primary_expr,

    call_expr :p    = "(" listOf(#assign_expr, ","):as ")"          -> __.CallExpr(p, as),

    member_expr :p  = ( "[" expr:e "]"                              -> __.MemberExpr(p, e)
                        |   "." "Id":i                              -> __.MemberExpr(p).name(i.value())
                        |   "->" "Id":i                             -> __.PointerExpr(p).name(i.value())  
                      ),

    primary_expr    = "Id"
                    | "Number"
                    | "String"
                    | "(" expr:e ")"                                -> __.GroupExpr(e),

    const_expr      = cond_expr:e                                   -> e.const(true),

    // Declaration statements
    // Statements that do "type" specification
    //

    declaration     = decl_specs:ds init_decl*:idec ";"             -> __.VarDeclStmt(ds, idec),

    decl_specs      = store_cl_spec:s decl_specs*:ds                -> { res = declattr();
                                                                         if (a.length === 0) {
                                                                            res.storage_class=s
                                                                         } else {
                                                                            res = a[0];
                                                                            res.storage_class=s
                                                                         };
                                                                         res
                                                                        }
                    | type_spec:t decl_specs*:ds                    -> { res = declattr();
                                                                         if (a.length === 0) {
                                                                            res.type_spec=t
                                                                         } else {
                                                                            res = a[0];
                                                                            res.type_spec=s
                                                                         };
                                                                         res
                                                                        }
                    | type_qualifier:t decl_specs*:ds               -> { res = declattr();
                                                                         if (a.length === 0) {
                                                                            res.type_qual=t
                                                                         } else {
                                                                            res = a[0];
                                                                            res.type_qual=t
                                                                         };
                                                                         res
                                                                        }

    init_decl       = declarator:d "=" initializer:i                -> __.VarBinding(d, i)
                    | declarator:d                                  -> __.VarBinding(d),

    store_cl_spec   = "extern" | "static" | "auto" | "register",

    type_spec       = "void" | "char" | "short" | "int" | "long"
                    | "float" | "double" | "signed" | "unsigned",

    type_qualifier  = "const"
                    | "volatile",

    declarator      = pointer:p dir_declarator:d                    -> {
                                                                         if (p.pointer_level > 0)
                                                                            d.pointer_level(p.pointer_level);
                                                                         if (p.pointer_type !== undefined)
                                                                            d.pointer_type(p.pointer_type);
                                                                         d;
                                                                        }
                    | dir_declarator,

    dir_declarator  = dir_declarator:d pmember_decl(d)
                    | dir_declarator:d pcall_decl(d)
                    | "(" declarator:d ")"                          -> d.func(true)
                    | "Id":s                                        -> __.Declarator().name(s),

    pmember_decl :p = "[ const_expr:e ]"                            -> {
                                                                         p.member(true);
                                                                         p.append(e);
                                                                         p;
                                                                        }
                    | "[" "]"                                       -> {
                                                                         p.member(true);
                                                                         p;
                                                                        },

    pcall_decl :p   = "(" ( param_type_lst:pl                       -> {
                                                                         p.call(true);
                                                                         p.append(pl);
                                                                         p;
                                                                        }
                            | ident_list:ll                         -> {
                                                                         p.call(true);
                                                                         p.append(ll);
                                                                         p;
                                                                        }
                            | empty ) ")"                           -> {
                                                                         p.call(true);
                                                                         p;
                                                                        }

    pointer         = "*"+:pn ( "const" | "volatile" )?:pt          -> {pointer_level:pn.length, pointer_type:pt}

    param_type_lst  = listOf(#param_decl, ","),

    param_decl      = decl_specs:ds declarator?:dl                  -> __.ParamDeclaration(dl, ds),

    initializer     = "{" listOf(#initializer_lst, ","):p "}"       -> __.GroupInitializer(p)
                    | assign_expr,

    initializer_lst = listOf(#initializer, ","),


    // C Statements
    //

    stmt            = labeled_stmt
                    | compound_stmt
                    | selection_stmt
                    | iteration_stmt
                    | jump_stmt
                    | expr_stmt,

    expr_stmt       = expr?:e ";"                                           -> __.ExprStmt(e),

    labeled_stmt    = "Id":l ":" stmt:s                                     -> __.LabeledStmt(l.value(), s)
                    | "case" const_expr:e ":" stmt:s                        -> __.CaseStmt(e, s)
                    | "default" ":" stmt:s                                  -> __.DefaultStmt(s),

    compound_stmt   = "{" declaration*:d stmt*:s "}",                       -> __.CompoundStmt(d, s),

    selection_stmt  = "if" "(" expr:e ")" stmt:s ( "else" stmt:f            -> __.IfStmt(e, s, f)
                                                    | empty                 -> __.IfStmt(e, s)
                                                 )
                    | "switch" "(" expr:e ")" stmt:s                        -> __.SwitchStmt(e, s),

    iteration_stmt  = "while" "(" expr:e ")" stmt:s                         -> __.WhileStmt(e, s)
                    | "do" stmt:s "while" "(" expr:e ")" ";"                -> __.DoWhileStmt(e, s)
                    | "for" "(" expr?:se ";" expr?:ee ";" expr?:ie ")" stmt:s   -> __.ForStmt(se, ee, ie, s),

    jump_stmt       = "goto" "Id":l ";"                         -> __.GotoStmt(l.value())
                    | "continue" ";"                            -> __.ContinueStmt()
                    | "break" ";"                               -> __.BreakStmt()
                    | "return" expr?:e ";"                      -> __.ReturnStmt(e),

    external_decl   = function_def
                    | declaration,

    function_def    = decl_specs?:ds declarator:dc compound_stmt:s      -> __.FuncDefinition(ds, dc, s),


    translation_u   = external_decl+:s                            -> __.Program(s),

//    topLevel        = translation_u:u spaces end        -> u
    topLevel        = ( spaces iteration_stmt )+:q spaces end		-> q
}


// Configure position information callback
CParser.position_info = function(input, from, to) {

    function position(pos) {
        var line  = 1,
        column = undefined;

        // scroll backwards to next linebreak
        for(var i=pos; i>=0; i--) {

            if(input[i] === "\n") {
                // only for the first time search column
                if(typeof column == 'undefined')
                    column = pos - i;

                line++
            }
        }

        if(line === 1)
            column = pos;

        return {
            line: line,
            column: column
        }
    }

    return {
        source: input.slice(from, to),
        start: position(from),
        end: position(to)
    }
};


CParser.spec = {

    // for C95.. we might have to add more keywords for C99
    keywords:   ["auto", "break", "case", "char", "const", "continue", "default",
                 "do", "double", "else", "enum", "extern", "float", "for", "goto",
                 "if", "int", "long", "register", "return", "short", "signed",
                 "sizeof", "static", "struct", "switch", "typedef", "union",
                 "unsigned", "void", "volatile", "while"],

    isKeyword:  function(k) { return this.keywords.indexOf(k) != -1; }
};


CParser.parse = function(input) {
    return CParser.matchAll(input, 'topLevel');
};

module.exports = CParser
