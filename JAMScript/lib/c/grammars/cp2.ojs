// Dependencies
var _       = require('../nodes.js');

ometa CParser  {

    // Helper Rules
    //
    isKeyword :x    = ?this.spec.isKeyword(x),
    nameFirst       = letter | '_',
    nameRest        = nameFirst | digit,
    linebreak       = '\n',

    // Comments
    //
    comment         = ``//'' (~linebreak char)* &linebreak
                    | fromTo('/*', '*/'),

    space           = ^space | comment | linebreak,

    // Identifiers and Names
    //
    iName           = <nameFirst nameRest*>,
    id              = iName:name ~isKeyword(name)                   -> _.Id(name),
    keyword         = iName:kwd isKeyword(kwd)                      -> _.Keyword(kwd),

    // Numeric Literals
    //
    hexDigit        = digit | range('a', 'f') | range('A', 'F'),
    hex             = <``0x''|``0X'' hexDigit+>:d                   -> _.Number(parseInt(d)).kind('hex'),

    decimalInt      = '0' | (~'0' digit) digit*,
    expPart         = ('e' | 'E') ('+' | '-')? digit+,

    octal           = <'0' digit+>:d                                -> _.Number(parseInt(d,8)).kind('oct'),

    decimal         = <'-'? decimalInt ('.' digit+)? expPart?>:f    -> _.Number(f).kind('float')
                    | <'-'? ('.' digit+) expPart?>:f                -> _.Number(f).kind('float'),

    integer         = <'-'? decimalInt>:d                           -> _.Number(parseInt(d)).kind('int'),

    number          = hex | octal | decimal | integer,

    // String Literals
    //
    escapeChar      = <'\\' char>:c                                 -> unescape(c),

    string          = '"' (escapeChar | ~'"' char)*:cs '"'          -> _.String(cs.join(''))
                    | ('#' | '`') iName:n                           -> _.String(cs.join('')),

    // Special symbols
    //
    special         = ( ``...'' | ``>>='' | ``<<='' | ``+='' | ``-=''
                  | ``*='' | ``/='' | ``%='' | ``&='' | ``^=''
                  | ``|='' | ``>>'' | ``<<'' | ``++'' | ``--''
                  | ``->'' | ``&&'' | ``||'' | ``<='' | ``>=''
                  | ``=='' | ``!='' | ';' | '{' | '}' | ','
                  | ':' | '=' | '(' | ')' | '[' | ']' | '.'
                  | '&' | '!' | '~' | '-' | '+' | '*' | '/'
                  | '%' | '<' | '>' | '^' | '|' | '?' ):s           -> _.Special(s),


    token: tt       = spaces ( (special | keyword):t ?(t.value == tt)               -> t
                    | (id | number | string):t ?(t[0] == tt)                        -> t
                    ),


    // Expressions
    //
    // TODO: arg_expr_list .. is it just an alias to expression?
    // FIXME: There could be a difference due to semantics..

    expr            = listOf(#assign_expr, ','):le                  -> (le.length > 1? _.SequenceExpr(le) : le[0]),

    assign_expr     = unary_expr:lhs assign_op:op assign_expr:rhs   -> _.AssignExpr(lhs, rhs).operator(op.value())
                    | cond_expr,

    cond_expr       = lor_expr:e "?" expression:t ":" cond_expr:f   -> _.CondExpr(e, t, f)
                    | lor_expr:e                                    -> e,

    // Binary operations
    //
    lor_expr        = lor_expr:x "||" lar_expr:y                    -> _.BinaryExpr(x, y).operator("||")
                    | lar_expr,
    lar_expr        = lar_expr:x "&&" ior_expr:y                    -> _.BinaryExpr(x, y).operator("||")
                    | ior_expr,
    ior_expr        = ior_expr:x "|" xor_expr:y                     -> _.BinaryExpr(x, y).operator("|")
                    | xor_expr,
    xor_expr        = xor_expr:x "^" and_expr:y                     -> _.BinaryExpr(x, y).operator("^")
                    | and_expr,
    and_expr        = and_expr:x "&" eq_expr:x                      -> _.BinaryExpr(x, y).operator("&")
                    | eq_expr,
    eq_expr         = eq_expr:x ( "==" | "!=" ):op rel_expr:y       -> _.BinaryExpr(x, y).operator(op.value())
                    | rel_expr,
    rel_expr        = rel_expr:x ( "<=" | "<"
                                    | ">=" | ">"):op shift_expr:y   -> _.BinaryExpr(x, y).operator(op.value())
                    | shift_expr,
    shift_expr      = shift_expr:x ( "<<" | ">>" ):op add_expr:y    -> _.BinaryExpr(x, y).operator(op.value())
                    | add_expr,
    add_expr        = add_expr:x ( "+" | "-" ) mult_expr:y          -> _.BinaryExpr(x, y).operator(op.value())
                    | mult_expr,
    mult_expr       = mult_expr:x ( "*" | "/" | "%" ) prefix_expr:y -> _.BinaryExpr(x, y).operator(op.value())
                    | prefix_expr,

    assign_op       = "=" | "*=" | "/=" | ">>=" | "<<=" | "+=" | "-="
                    | "%=" | "&=" | "|=" | "^=",

    // Unary operators
    //

    //
    prefix_expr     = ( "++" | "--" ):op spacesNoNl unary_expr:e    -> _.UpdateExpr(e).operator(op.value())
                    | unary_expr,

    //
    unary_expr      = ( "&" | "*" | "+" | "-"
                            | "~" | "!" ):op prefix_expr:e          -> _.UnaryExpr(e).operator(op.value())
                    | "sizeof" unary_expr:e
                    | postfix_expr,

    postfix_expr    = left_expr:e spacesNoNl ( "++" | "--" ):op     -> _.UpdateExpr(e).operator(op.value()).prefix(false),

    left_expr       = left_expr:p call_expr(p)
                    | left_expr:p member_expr(p)
                    | primary_expr,

    call_expr :p    = "(" listOf(#assign_expr, ','):as ")"          -> _.CallExpr(p, as),

    member_expr :p  = ( "[" expression:e "]"                        -> _.MemberExpr(p, e)
                        |   "." "id":i                              -> _.MemberExpr(p).name(i.value())
                        |   "->" "id":i                             -> _.PointerExpr(p).name(i.value())
                      ),

    primary_expr    = "id"
                    | "const"
                    | "string"
                    | "(" expression:e ")"                          -> _.GroupExpr(e),

    const_expr      = cond_expr,

    // Declaration statements
    // Statements that do "type" specification
    //

    declaration     = decl_specs:ds init_decl*:id ";"               -> _.MakeDeclaration(ds, idec),

    decl_specs      = store_cl_spec:s decl_specs*:ds                -> ds.concat(s)
                    | type_spec:t decl_specs*:ds                    -> ds.concat(t)
                    | type_qualifier:t decl_specs*:ds               -> ds.concat(t),

    init_decl       = declarator:d "=" initializer:i                -> _.InitDeclarator(d, i)
                    | declarator:d                                  -> _.InitDeclarator(d),

    store_cl_spec   = "extern" | "static" | "auto" | "register",

    type_spec       = "void" | "char" | "short" | "int" | "long"
                    | "float" | "double" | "signed" | "unsigned",

    type_qualifier  = "const"
                    | "volatile",

    declarator      = pointer:p dir_declarator:d                    -> _.PointerDeclarator(d, p)
                    | dir_declarator,

    dir_declarator  = dir_declarator:d pmember_decl(d)
                    | dir_declarator:d pcall_decl(d)
                    | "(" declarator ")"
                    | "id",

    pmember_decl :p = "[ const_expr:e ]"                            -> _.MemberDecl(p, e)
                    | "[" "]"                                       -> _.MemberDecl(p),

    pcall_decl :p   = "(" ( param_type_lst |
                            ident_list |
                            empty ):g ")"                           -> _.GroupDecl(p, g),

    pointer         = "*"+:pn ( "const" | "volatile" ):pt           -> _.PointerType(pt, pn),

    param_type_lst  = listOf(#param_decl, ","),

    param_decl      = decl_specs:ds declarator?:dl                  -> _.ParamDeclaration(dl, ds),

    initializer     = "{" listOf(#initializer_lst, ","):p "}"       -> _.GroupInitializer(p)
                    | assign_expr,

    initializer_lst = listOf(#initializer, ","),


    // C Statements
    //

    stmt            = labeled_stmt
                    | compound_stmt
                    | selection_stmt
                    | iteration_stmt
                    | jump_stmt
                    | expr_stmt,

    expr_stmt       = expr?:e ";"                                           -> _.ExprStmt(e),

    labeled_stmt    = "id":l ":" stmt:s                                     -> _.LabeledStmt(l.value(), s)
                    | "case" const_expr:e ":" stmt:s                        -> _.CaseStmt(e, s)
                    | "default" ":" stmt:s                                  -> _.DefaultStmt(s),

    compound_stmt   = "{" declaration*:d stmt*:s "}"                        -> _.CompoundStmt(d, s),

    selection_stmt  = "if" "(" expr:e ")" stmt:s ( "else" stmt:f            -> _.IfStmt(e, s, f)
                                                    | empty                 -> _.IfStmt(e, s)
                                                 )
                    | "switch" "(" expr:e ")" stmt:s                        -> _.SwitchStmt(e, s),

    iteration_stmt  = "while" "(" expr:e ")" stmt:s                         -> _.WhileStmt(e, s)
                    | "do" stmt:s "while" "(" expr:e ")" ";"                -> _.DoWhileStmt(e, s)
                    | "for" "(" expr?:se ";" expr?:ee ";" expr?:ie ")" stmt:s   -> _.ForStmt(se, ee, ie, s),

    jump_stmt       = "goto" "id":l ";"                         -> _.GotoStmt(l.value())
                    | "continue" ";"                            -> _.ContinueStmt()
                    | "break" ";"                               -> _.BreakStmt()
                    | "return" expr?:e ";"                      -> _.ReturnStmt(e),

    external_decl   = function_def
                    | declaration,

    function_def    = decl_specs?:ds declarator:dc compound_stmt:s      -> _.FuncDeclare(ds, dc, s),


    translation_u   = external_decl+,

//    topLevel        = translation_u spaces end
    topLevel        = expr+ spaces end
}


// Configure position information callback
CParser.position_info = function(input, from, to) {

    function position(pos) {
        var line  = 1,
        column = undefined;

        // scroll backwards to next linebreak
        for(var i=pos; i>=0; i--) {

            if(input[i] === "\n") {
                // only for the first time search column
                if(typeof column == 'undefined')
                    column = pos - i;

                line++
            }
        }

        if(line === 1)
            column = pos;

        return {
            line: line,
            column: column
        }
    }

    return {
        source: input.slice(from, to),
        start: position(from),
        end: position(to)
    }
};


CParser.spec = {

    // for C95.. we might have to add more keywords for C99
    keywords:   ["auto", "break", "case", "char", "const", "continue", "default",
                 "do", "double", "else", "enum", "extern", "float", "for", "goto",
                 "if", "int", "long", "register", "return", "short", "signed",
                 "sizeof", "static", "struct", "switch", "typedef", "union",
                 "unsigned", "void", "volatile", "while"],

    isKeyword:  function(k) { return this.keywords.indexOf(k) != -1; }
};


CParser.parse = function(input) {
    return CParser.matchAll(input, 'topLevel');
};

module.exports = CParser
