/**
 * Copyright (c) 2015 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENSE file at the root of the project for the full license.
 *
 * This translator borrows quite liberally from the awesome ES5Translator built by
 * Jonathan Brachth√§user (http://b-studios.de).
 */

// Dependencies
var JsonMLWalker = require('../../../deps/jsonml/grammars/jsonml_walker.ojs'),
    join         = require('../../../utils.js').join,
    getNum       = require('../../../utils.js').getNum,
    escape       = require('../../../utils.js').escape_string;


ometa CTranslator <: JsonMLWalker {

    // Literals
    //
    Id              :n                                                                  -> n.value(),

    Number          :n  = ?n.is('kind', 'hex')                                          -> join('0x', n.value().toString(16))
                        | ?n.is('kind', 'oct')                                          -> join('0', n.value().toString(8))
                        | ?n.is('kind', 'char')                                         -> getNum(n.original())
                        | ?n.is('value', parseFloat(n.original()))                      -> n.original()           // if something changed then don't
                        | empty                                                         -> n.value().toString(),  // use the original string representation

    String          :n                                                                  -> join('"', escape(n.value()), '"'),

    // Expressions
    //
    SequenceExpr    :n  = walk*:es                                                      -> es.join(', '),

    AssignExpr      :n  = walk:lhs walk:rhs                                             -> join(lhs, ' ', n.operator(), ' ', rhs),

    CondExpr        :n  = walk:ce walk:t walk:f                                         -> join(ce, ' ? ', t, ' : ', f),

    BinaryExpr      :n  = walk:lhs walk:rhs                                             -> join(lhs, ' ', n.operator(), ' ', rhs),

    UpdateExpr      :n = walk:e ( ?n.is('prefix')                                       -> join(n.operator(), e)
                                | empty                                                 -> join(e, n.operator())
                                ),

    UnaryExpr       :n = walk:e ( ?n.operator().match(/^[+-~!*&]$/)                     -> join(n.operator(), e)
                                | empty                                                 -> join(n.operator(), ' ', e)
                                ),

    CallExpr        :n = walk:e walk*:args                                              -> join(e, '(', args.join(', '), ')'),

    MemberExpr      :n = ?n.is('access', 'name') walk:e                                 -> join(e, '.', n.name())
                       | walk:e walk:ae                                                 -> join(e, '[', ae, ']'),

    PointerExpr     :n = ?n.is('access', 'pointer') walk:e                              -> join(e, '->',  n.name()),

    GroupExpr       :n = walk:e                                                         -> join('(', e, ')'),

    // Declarations
    //

    StorageClassSpec    :n = empty                                                      -> n.class(),

    TypeSpec    :n     = walk?:e                                                        -> {["enum", "struct", "union"].indexOf(n.type()) > -1 ? e : n.type(); },

    TypeQual    :n     = empty                                                          -> n.type(),

    DeclSpec    :n     = walk+:l                                                        -> l.join(' '),

    Declaration     :n = walk:ds walk+:l                                                -> join(ds, l.join(','), ';'),

    InitDecl    :n     = walk:d walk?:i                                                 -> {i !== undefined ? join(d, ' = ', i) : d},

    Declarator      :n = ?n.is('type', 'member') walk:e                                 -> {join(this.print_ptr(n), n.name(), '[', e, ']')}
                       | ?n.is('type', 'call') walk+:e                                  -> {join(this.print_ptr(n), n.name(), '(', e.join(', '), ')')}
                       | ?n.is('type', 'func')                                          -> join(this.print_ptr(n), '(', n.name(), ')')
                       | empty                                                          -> {
                                                                                            if (n.is('type', 'member'))
                                                                                                return join(this.print_ptr(n), n.name(), '[]');
                                                                                            else if (n.is('type', 'call'))
                                                                                                return join(this.print_ptr(n), n.name(), '()');
                                                                                            else
                                                                                                return join(this.print_ptr(n), n.name());
                                                                                           },

    ParamDeclaration  :n = walk:ds walk:d                                               -> join(ds, ' ', d),

    GroupInitializer  :n = walk+:p                                                      -> join('{', p.join(','), '}'),

    EnumDeclaration     :n  = walk*:d                                                   -> {d.length > 0? join('enum ', n.name(), ' {', d.join(','), '} ') : join('enum ', n.name())},

    Enumerator      :n = walk?:d                                                        -> {d !== undefined? join(n.name(), ' = ', d) : n.name()},

    StrucSpec       :n = walk*:s                                                        -> {s.length > 0? join('struct ', n.name(), ' {', s.join('\n'), '}') : join('struct ', n.name())},

    UnionSpec       :n = walk*:s                                                        -> {s.length > 0? join('union ', n.name(), ' {', s.join('\n'), '}') : join('union ', n.name())},

    StrucDecl       :n = walk:s walk*:l                                                 -> join(s, l.join(','), ';'),

    SpecQList       :n = walk+:l                                                        -> l.join(' '),

    SDeclarator     :n = walkType(#Declarator)?:d walk?:e                               -> { if (d === undefined)
                                                                                                return join(": ", e);
                                                                                             else if (e === undefined)
                                                                                                return d;
                                                                                             else
                                                                                                return join(d, " : ", e);
                                                                                           },

    // Statements
    //

    ExprStmt        :n = walk*:s                                                        -> join(s.join('\n'), ";"),

    LabeledStmt     :n = walk:s                                                         -> join(n.label(), ': ', s),

    CaseStmt        :n = walk:ex walk:st                                                -> join('case ', ex, ':', st, ';'),

    DefaultStmt     :n = walk:s                                                         -> join('default:', s, ';'),

    CompoundStmt    :n = walk*:d walk*:s                                                -> join('{\n', this.indent(this.join_sc(d)), this.indent(this.join_sc(s)), '}\n'),

    IfStmt          :n = walk:c walk:t ( walk:f                                         -> join('if(', c, ') ', t, ' else ', f, ';')
                                               | (undefined | empty)                    -> join('if(', c, ') ', t, ';')
                                               ),

    SwitchStmt      :n = walk:se walk:st                                                -> join('switch', '(', se, ')', st, ';'),

    WhileStmt       :n = walk:ce walk:s                                                 -> join('while(', ce, ') ', s, ';'),

    DoWhileStmt     :n = walk:s walk:ce                                                 -> join('do ', ce, ' while(', s, ')', ';'),

    ForStmt         :n = walk:ie walk:ce walk:ue walk:s                                 -> join('for(', ie, '; ', ce, '; ', ue, ') ', s, ';'),

    GotoStmt        :n = empty                                                          -> join('goto ', n.label(), ';'),

    ContinueStmt    :n = empty                                                          -> 'continue;',

    BreakStmt       :n = empty                                                          -> 'break;',

    ReturnStmt      :n = walk:e ( ?(e !== undefined)                                    -> join('return ', e, ';')
                                | empty                                                 -> 'return;'
                                ),

    // Function or Program Statements
    //

    FuncDefinition  :n = walk?:ds walk:de walk:st                                       -> {ds === undefined? join(de, st) : join(ds, de, st)},

    Program         :n = walk*:cs                                                       -> cs.join('\n')

}

CTranslator.print_ptr = function(n) {
    var pointdata = [],
        i = 0;
    while (i++ < n.pointer_level())
        pointdata.push("*");

    pointdata.push(" ");
    if (n.pointer_type() !== undefined)
        pointdata.push(n.pointer_type());

    return pointdata.join('');
}


// join with semicolons and linebreaks
CTranslator.join_sc = function(cs) {

    var output = [];

    for(var i = 0; i < cs.length; i++)
        output.push(cs[i]);
    return output.join('\n');
};

CTranslator.indent = function(source, opts) {

    opts = opts || {};

    function defaults(key, value) { if(typeof opts[key] == 'undefined') opts[key] = value; }

    defaults('width',      this.tab_width);
    defaults('first_line', true);

    var space = Array(opts.width+1).join(' ');
    return (opts.first_line ? space : '') + source.split('\n').join('\n' + space);
};

CTranslator.tab_width = 4;
CTranslator.force_rules = true;
CTranslator.translate = function(input) {
    return CTranslator.match(input, 'walk');
};

module.exports = CTranslator;
