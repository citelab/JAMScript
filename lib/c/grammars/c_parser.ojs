
/**
 * Copyright (c) 2015 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENSE file at the root of the project for the full license.
 *
 * This parser borrows quite liberally from the awesome ES5Parser built by
 * Jonathan Brachth√§user (http://b-studios.de). But, don't worry this implements
 * a C grammar and not a JavaScript grammar as ES5!
 */


// Dependencies
var __      = require('../nodes.js');


/**
 * Reduced C: This parser accepts a subset of the C language.
 * I want to get the JAMScript up and running to hash out the many problems we
 * would encounter in deploying a 'bridge' language and understand what we could do
 * with it.
 *
 * Simplifications:
 * - no typedefs
 * - only basic pointer patterns
 * - no suffix for constants like integers or floats
 * - no prefix for strings
 * - need to check with the full C95 specification for other omissions
 */



ometa CParser  {

    // Helper Rules
    //
    isKeyword :x    = ?this.spec.isKeyword(x),
    isTypename :x   = ?this.spec.isTypename(x),
    nameFirst       = ^letter | '_',
    nameRest        = nameFirst | ^digit,
    linebreak       = '\n',


    // Comments
    //
    comment         = ``//'' (~linebreak char)* &linebreak
                    | fromTo('/*', '*/'),

    space           = ^space | comment | linebreak,
    spacesNoNl      = (~linebreak space)*,

    // Identifiers and Names
    //
    iName           = <nameFirst nameRest*>,
    id              = iName:name ~isKeyword(name) ~isTypename(name)  -> __.Id(name),
    keyword         = iName:kwd isKeyword(kwd)                       -> __.Keyword(kwd),
    typename        = iName:kwd isTypename(kwd)                      -> __.Typename(kwd),

    // Numeric Literals
    //
    hexDigit        = ^digit | range('a', 'f') | range('A', 'F'),
    hex             = <(``0x''|``0X'') hexDigit+>:d 'L'?                        -> __.Number(parseInt(d)).kind('hex'),

    octalDigit      = range('0', '7'),

    decimalInt      = '0' | (~'0' digit) digit*,
    expPart         = ('e' | 'E') ('+' | '-')? digit+,

    octal           = <'0' octalDigit+>:d 'L'?                                  -> __.Number(parseInt(d,8)).kind('oct'),

    decimal         = <'-'? decimalInt expPart>:f 'f'?                          -> __.Number(f).kind('float')
                    | <'-'? decimalInt? '.' digit+ expPart?>:f 'f'?             -> __.Number(f).kind('float'),

    integer         = <'-'? decimalInt>:d 'L'?                                  -> __.Number(parseInt(d)).kind('int'),

    charLit         = '\'' '\\' <octalDigit octalDigit? octalDigit?>:cs '\''    -> __.Number(cs).kind('char_oct')
                    | '\'' '\\' 'x' <(~'\'' hexDigit)+>:cs '\''                 -> __.Number(cs).kind('char_hex')
                    | '\'' escapeChar:cs   '\''                                 -> __.Number(cs).kind('char_escape')
                    | '\'' <(~'\'' char)*:cs> '\''                              -> __.Number(cs).kind('char'),

    number          = charLit | hex | octal | decimal | integer,

    // String Literals
    //
    escapeChar      = <'\\' char>:c                                 -> unescape(c),

    string          = '"' (escapeChar | ~'"' char)*:cs '"'          -> __.String(cs.join(''))
                    | ('#' | '`') iName:n                           -> __.String(cs.join('')),

    // Punctuator symbols
    //
    punctuator      = ( ``...'' | ``>>='' | ``<<='' | ``+='' | ``-=''
                    | ``*='' | ``/='' | ``%='' | ``&='' | ``^=''
                    | ``|='' | ``>>'' | ``<<'' | ``++'' | ``--''
                    | ``->'' | ``&&'' | ``||'' | ``<='' | ``>=''
                    | ``=='' | ``!='' | ';' | '{' | '}' | ','
                    | ':' | '=' | '(' | ')' | '[' | ']' | '.'
                    | '&' | '!' | '~' | '-' | '+' | '*' | '/'
                    | '%' | '<' | '>' | '^' | '|' | '?' ):s           -> __.Punctuator(s),


    token :tt       = spaces ( ( punctuator | keyword):t ?(t.value() == tt)      -> t
                    | (id | number | string | typename):t ?(t[0] == tt)          -> t
                    ),


    // Expressions
    //
    // TODO: arg_expr_list .. is it just an alias to expression?
    // FIXME: There could be a difference due to semantics..

    listof :p       = apply(p):x ("," apply(p))*:y                  -> {y.unshift(x); y},

    expr            =  listof(#assign_expr):le                      -> (le.length > 1? __.SequenceExpr(le) : le[0]),


    assign_expr     = unary_expr:lhs assign_op:op assign_expr:rhs   -> __.AssignExpr(lhs, rhs).operator(op.value())
                    | cond_expr,

    cond_expr       = lor_expr:e "?" expr:t ":" cond_expr:f         -> __.CondExpr(e, t, f)
                    | lor_expr,


    // Binary operations
    //
    lor_expr        = lor_expr:x "||" lar_expr:y                    -> __.BinaryExpr(x, y).operator("||")
                    | lar_expr,
    lar_expr        = lar_expr:x "&&" ior_expr:y                    -> __.BinaryExpr(x, y).operator("&&")
                    | ior_expr,
    ior_expr        = ior_expr:x "|" xor_expr:y                     -> __.BinaryExpr(x, y).operator("|")
                    | xor_expr,
    xor_expr        = xor_expr:x "^" and_expr:y                     -> __.BinaryExpr(x, y).operator("^")
                    | and_expr,
    and_expr        = and_expr:x "&" eq_expr:y                      -> __.BinaryExpr(x, y).operator("&")
                    | eq_expr,
    eq_expr         = eq_expr:x ( "==" | "!=" ):op rel_expr:y       -> __.BinaryExpr(x, y).operator(op.value())
                    | rel_expr,
    rel_expr        = rel_expr:x ( "<=" | "<"
                                    | ">=" | ">"):op shift_expr:y   -> __.BinaryExpr(x, y).operator(op.value())
                    | shift_expr,
    shift_expr      = shift_expr:x ( "<<" | ">>" ):op add_expr:y    -> __.BinaryExpr(x, y).operator(op.value())
                    | add_expr,
    add_expr        = add_expr:x ( "+" | "-" ):op mult_expr:y          -> __.BinaryExpr(x, y).operator(op.value())
                    | mult_expr,
    mult_expr       = mult_expr:x ( "*" | "/" | "%" ):op prefix_expr:y -> __.BinaryExpr(x, y).operator(op.value())
                    | prefix_expr,

    assign_op       = "=" | "*=" | "/=" | ">>=" | "<<=" | "+=" | "-="
                    | "%=" | "&=" | "|=" | "^=",


    // Unary operators
    //

    //
    prefix_expr     = ( "++" | "--" ):op spacesNoNl unary_expr:e    -> __.UpdateExpr(e).operator(op.value())
                    | cast_expr                                     
                    | unary_expr,

    //
    unary_expr      = ( "&" | "*" | "+" | "-"
                            | "~" | "!" ):op prefix_expr:e          -> __.UnaryExpr(e).operator(op.value())
                    | "sizeof" unary_expr:e                         -> __.UnaryExpr(e).operator("sizeof")
                    | "sizeof" "(" type_spec:t ")"                  -> __.UnaryExpr().operator("sizeof(" + t.type() + ")")
                    | postfix_expr,

    cast_expr       = unary_expr
                    | "(" type_spec+:t ")" cast_expr:e              -> __.UpdateExpr(e).operator("(" + t.map(function(e){return e.type();}).join(" ") + ")"),

    postfix_expr    = left_expr:e spacesNoNl ( "++" | "--" ):op     -> __.UpdateExpr(e).operator(op.value()).prefix(false)
                    | left_expr,

    left_expr       = left_expr:p call_expr(p)
                    | left_expr:p member_expr(p)
                    | primary_expr,

    call_expr :p    = "(" listOf(#assign_expr, ","):as ")"          -> __.CallExpr(p, as),

    member_expr :p  = ( "[" expr:e "]"                              -> __.MemberExpr(p, e)
                        |   "." "Id":i                              -> __.MemberExpr(p).name(i.value())
                        |   "->" "Id":i                             -> __.PointerExpr(p).name(i.value())
                      ),

    primary_expr    = "Id"
                    | "Number"
                    | "String"
                    | "(" expr:e ")"                                -> __.GroupExpr(e),

    const_expr      = cond_expr:e                                   -> e,

    // Declaration statements
    // Statements that do "type" specification
    //

    declaration     = decl_specs:ds ?(ds[2].hasType(#StorageClassSpec) && ds[2].class() === #typedef)
                                    init_decl_lst:idec ";"          -> {this.spec.addTypename(idec[0][2].name()); __.Declaration(ds, idec)}
                    | decl_specs:ds init_decl_lst:idec ";"          -> __.Declaration(ds, idec),

    decl_specs      = (store_cl_spec | type_spec | type_qualifier)+:s   -> __.DeclSpec(s),

    init_decl_lst   = listOf(#init_decl, ','),

    init_decl       = declarator:d "=" initializer:i                -> __.InitDecl(d, i)
                    | declarator:d                                  -> __.InitDecl(d),

    store_cl_spec   = ("typedef" | "extern" | "static"
                    | "auto" | "register"):s                            -> __.StorageClassSpec().class(s.value()),

    type_spec       = ("void" | "char" | "short" | "int" | "long"
                    | "float" | "double" | "signed" | "unsigned"):s     -> __.TypeSpec().type(s.value())
                    | enum_spec:e                                       -> __.TypeSpec(e).type("enum")
                    | struct_spec:e                                     -> __.TypeSpec(e).type("struct")
                    | union_spec:e                                      -> __.TypeSpec(e).type("union")
                    | "Typename":t                                      -> __.TypeSpec().type(t.value()),

    struct_spec     = "struct" "Id":s "{" struct_decl+:l "}"            -> __.StrucSpec(l).name(s.value())
                    | "struct" "Id":s                                   -> __.StrucSpec().name(s.value())
                    | "struct" "{" struct_decl+:l "}"                   -> __.StrucSpec(l),


    union_spec      = "union" "Id":s "{" struct_decl+:l "}"             -> __.UnionSpec(l).name(s.value())
                    | "union" "Id":s                                    -> __.UnionSpec().name(s.value())
                    | "union" "{" struct_decl+:l "}"                    -> __.UnionSpec(l),

    struct_decl     = spec_qual_list:s listOf(#sdeclarator, ","):l ";"      -> __.StrucDecl(s,l),

    spec_qual_list  = (type_spec | type_qualifier)+:l                   -> __.SpecQList(l),

    sdeclarator     = declarator:d ":" const_expr:e                     -> __.SDeclarator(d, e)
                    | declarator:d                                      -> __.SDeclarator(d)
                    | ":" const_expr:e                                  -> __.SDeclarator(e),

    enum_spec       = "enum" "Id":s "{" listOf(#enumerator, ","):e "}"  -> __.EnumDeclaration(e).name(s.value())
                    | "enum" "Id":s                                     -> __.EnumDeclaration().name(s.value())
                    | "enum" "{" listOf(#enumerator, ","):e "}"         -> __.EnumDeclaration(e),

    enumerator      = "Id":s "=" const_expr:e                           -> __.Enumerator(e).name(s.value())
                    | "Id":s                                            -> __.Enumerator().name(s.value()),


    type_qualifier  = ("const"
                    | "volatile"):e                                 -> __.TypeQual().type(e.value()),

    declarator      = pointer:p dir_declarator:d                    -> { d.set(p); d }
                    | pointer:p                                     -> __.Declarator().set(p)
                    | dir_declarator,

    dir_declarator  = dir_declarator:d pmember_decl(d)
                    | dir_declarator:d pcall_decl(d)
                    | "(" declarator:d ")"                          -> {d.type('func'); d}
                    | "Id":s                                        -> __.Declarator().name(s.value()),

    pmember_decl :p = "[" const_expr:e "]"                          -> { p.type('member'); p.append(e); p }
                    | "[" empty "]"                                 -> { p.type('member'); p },

    pcall_decl :p   = "(" ( &keyword param_type_lst:pl              -> { p.type('call'); p.appendAll(pl); p }
                            | ident_list:ll                         -> { p.type('call'); p.appendAll(ll); p }
                            | empty ) ")"                           -> { p.type('call'); p },

    pointer         = "*"+:pn ( "const" | "volatile" )?:pt          -> {pointer_level:pn.length, pointer_type:pt === undefined? pt : pt.value()},


    ident_list      = listOf(#id, ','),

    param_type_lst  = listOf(#param_decl, ","):p ',' var_args:a     -> {p.push(a);p}
                    | listOf(#param_decl, ","):p                    -> p,

    var_args        = "..."                                         -> __.VarArgs(),

    param_decl      = decl_specs:ds declarator?:dl                  -> __.ParamDeclaration(ds, dl),

    initializer     = "{" listOf(#initializer, ","):p ","? "}"       -> __.GroupInitializer((p.length > 1? __.SequenceExpr(p) : p[0]))
                    | assign_expr,


    // C Statements
    //

    stmt            = labeled_stmt
                    | compound_stmt
                    | selection_stmt
                    | iteration_stmt
                    | jump_stmt
                    | expr_stmt,

    expr_stmt       = expr?:e ";"                                           -> __.ExprStmt(e),

    labeled_stmt    = "Id":l ":" stmt:s                                     -> __.LabeledStmt(l.value(), s)
                    | "case" const_expr:e ":" stmt:s                        -> __.CaseStmt(e, s)
                    | "default" ":" stmt:s                                  -> __.DefaultStmt(s),

    compound_stmt   = "{" declaration*:d stmt*:s "}"                        -> __.CompoundStmt(d, s),

    selection_stmt  = "if" "(" expr:e ")" stmt:s ( "else" stmt:f            -> __.IfStmt(e, s, f)
                                                    | empty                 -> __.IfStmt(e, s)
                                                 )
                    | "switch" "(" expr:e ")" stmt:s                        -> __.SwitchStmt(e, s),

    iteration_stmt  = "while" "(" expr:e ")" stmt:s                         -> __.WhileStmt(e, s)
                    | "do" stmt:s "while" "(" expr:e ")" ";"                -> __.DoWhileStmt(e, s)
                    | "for" "(" expr?:se ";" expr?:ee ";" expr?:ie ")" stmt:s   -> __.ForStmt(se, ee, ie, s),

    jump_stmt       = "goto" "Id":l ";"                         -> __.GotoStmt().label(l.value())
                    | "continue" ";"                            -> __.ContinueStmt()
                    | "break" ";"                               -> __.BreakStmt()
                    | "return" expr?:e ";"                      -> __.ReturnStmt(e),

    external_decl   = function_def
                    | declaration,

    function_def    = decl_specs?:ds declarator:dc compound_stmt:s      -> __.FuncDefinition(ds, dc, s),

    translation_u   = external_decl+:s                            -> __.Program(s),

    topLevel        = translation_u:u spaces end    -> u
}


// Configure position information callback
CParser.position_info = function(input, from, to) {

    function position(pos) {
        var line  = 1,
        column = undefined;

        // scroll backwards to next linebreak
        for(var i=pos; i>=0; i--) {

            if(input[i] === "\n") {
                // only for the first time search column
                if(typeof column == 'undefined')
                    column = pos - i;

                line++
            }
        }

        if(line === 1)
            column = pos;

        return {
            line: line,
            column: column
        }
    }

    return {
        source: input.slice(from, to),
        start: position(from),
        end: position(to)
    }
};


CParser.spec = {

    // for C95.. we might have to add more keywords for C99
    keywords:   ["auto", "break", "case", "char", "const", "continue", "default",
                 "do", "double", "else", "enum", "extern", "float", "for", "goto",
                 "if", "int", "long", "register", "return", "short", "signed",
                 "sizeof", "static", "struct", "switch", "typedef", "union",
                 "unsigned", "void", "volatile", "while"],

    addKeywords:    function(l) { if (Array.isArray(l)) { this.keywords = this.keywords.concat(l); } },

    isKeyword:  function(k) { return this.keywords.indexOf(k) != -1; },

    typenames:   ["__builtin_va_list"],

    addTypename:   function(l) { this.typenames.push(l); },

    isTypename:  function(k) { return this.typenames.indexOf(k) != -1; }

};


CParser.parse = function(input) {
    return CParser.matchAll(input, 'topLevel');
};

module.exports = CParser
