March 27th Notes
================
    Remote execution
        = Sync
        = Async

    Get both done.
    



March 24th Notes
================
    = Work on jamlib ...




March 23rd Notes
================

High precision timer could be used for sequence numbers, activity serial numbers, etc.
We need worry about the collision that could happen with two cores (J and C) selecting
sequence numbers at the same time.


bgthread design
    = Get all the file descriptors and put them into the poller
    = Wait on the poller
    = Initialize a type array that will allow us to branch into the correct
        method for processing the decriptor. The type array is as long as the
        number of open descriptors and it maps the file descriptor to the
        type of processing routine.
    We read the file descriptor and use the type array to figure out the processor
    type that should handle the event

    Go into the processing loop.

    = Survey packets
    = Publish packets
    = Local request packets
    = Reply packets for the request packets
    =



March 19th Notes
================

We should have namespaces too. Their values is important for
discovering activities.


In the bgthread do the following:
    Read packet off the external sockets
    Parse the packet into a command structure.
    Do the actions depending on the packet type.

    Pubsub packets could be for the following:
        = Need to execute X:

        = Completed the execution of X on J:

        = What else?

    Survey packets could be for the following:
        = Is anyone executing X?

        = What else?










=== testers: nvoid, activity, context..

= develop the testers
= Remote exec.. as described below


Plans March 8, 2016
===================

IMPORTANT: Do we restrict activities such that there is no recursive calls?
Activity X cannot call X again either directly or indirectly.


C-core calling J-core

= Marshall the parameters
= Get the activity ID
= Stick the activity ID in the request for remote execution
= Activity state = NEW

= Send the remove execution request. Wait for acknowledgement.
= Once we receive the acknowledgment, make
    Activity state = RUNNING
  If we fail to get the ack after many tries, make
    Activity state = TIMEDOUT

= Get the lease time from the ack from the remote side

= Add a timer call for the activity

= When we receive a timer expiry, we check the health
    of the corresponding activity.
    If the activity health check fails, we timeout
    the execution of the activity with a failure.

============= Challenge!!

= If the activity is synchronous, we need to wait
    for one of the following conditions:
        = timeout failure of the activity execution
        = successful completion of the activity
        = erroneous run of the activity - similar to the timeout

= If the activity is asynchronous, we don't wait
......???

Asynchronous .. what do we do?
        = we have the user program running..
        = "yield" routines are embedded in the user program
        = yield checks for background executions.. after checking we always
            return back to the main thread

wait for asynchronous activity
    = is a yield statement, where we yield the user execution
        until we have a "reply" of some sort for the activity

The only difference between the two: sync and async
    = sync we call the yield as soon as we complete the invocation

We need to develop a "yield" or context switch routine.
    = Need to ensure that this is built on non deprecated functions





















New Plans
=========

= Get CBOR working from C side:
    = Create a routine for encoding a command and print it to the screen.
    = Retrieve standard input (file redirect) and decode the CBOR and
        retrieve the command.
    (The second one responsible for retrieving network data and
    recovering the command.)

= Use the nanomsg and rewrite the Socket routines in the previous jamlib.

= C->JS transfers through CBOR
= JS->C transfer through CBOR

= C->JS & JS->C working with CBOR and nanomsg

Modify the jamlib routines to work with the new combination
    = CBOR
    = nanomsg

Improve the jamlib to the new architecture
    = Fog
    = Cloud
    = Handle fault tolerance

Activity logging with new jamlib

Activity accumulation to the cloud central


NOTE 1: Rethink the use of assert(). We need something that would implement
assert differently and also log the important events.

NOTE 2: Should logging or the direction of message flow be part of the command?



Old Plans
=========




Respond to Ping
    This could be a heartbeat for a running request too.

Respond to Survey
    A request to run an activity comes through the survey.

    A heartbeat request for running activity comes through the survey

    Are you there type of queries come through survey

Get Subscriptions
    This could be triggering some local callbacks on the pub-sub messages.


Fog server holds all the sockets..
    including the REQREP ones!

Step 1:
=======
First the list of FOG_SERVERs are tried and then CLOUD_SERVERs are attempted.

If the FOG_SERVER is found, we should get the config information from that
server.

CLOUD_SERVER has a all-Fog registry. Send a survey to that address seeking
a Fog for for the application we are running right now... given by
APP_NAME

= Perform survey
= Perform request and expect result

= Process survey
= Process request
= Process publish

Step 2:
=======
Register the c-core with the Fog so that the c-core could respond to the
surveys send out by the Fog server.


Step 3:
=======
Run a J-core activity. Activity we need to ask the J-core to run for the C-core.
Reliability management is big part of the execution protocol. We also need to make sure
that the protocol does not depend on the run time of the application so we
can use timeouts in a sane manner.

Step 4:
=======
Run a C-core activity.
