/**
 * Copyright (c) 2015 Muthucumaru Maheswaran <mahes25@gmail.com>
 *
 * See the LICENSE file at the root of the project for the full license.
 */

// Dependencies
var CTranslator  = require('../../c/grammars/c_translator.ojs'),
    ES5Translator = require('../../../deps/es5/grammars/es5_translator.ojs'),
    join         = require('../../../utils.js').join,
    escape       = require('../../../utils.js').escape_string;

var ActivityID   = 0;

ometa JAMCTranslator <: CTranslator {

    NamespaceSpec :n = empty                                                            -> n.name(),

    JDeclaration :n = walk:s walk:d walk?:na      -> this.rules.JDeclaration(this, n.sync(), n[3], s, d, na),

    ODeclaration :n = walk:t walk*:p             -> this.rules.ODeclaration(this, n.type(), t, p),

    CompoundStmt :n = ?this.context.TarActivityCtx() walk*:d walk*:s                  -> this.rules.CompoundStmt(this, d, s)
                    | ^CompoundStmt,

    BlockStmt    :n = ?this.context.TarActivityCtx() ES5Translator.walk*:cs           -> this.rules.BlockStmt(this, cs)
                    | ES5Translator.BlockStmt,

    CompleteBlock :n = walk:d ES5Translator.walk:s                                     -> this.rules.CompleteBlock(this, d, s),

    ErrorBlock   :n = walk:d ES5Translator.walk:s                                       -> this.rules.ErrorBlock(this, d, s),

    LoadBlock    :n = walk:d ES5Translator.walk:s                                       -> this.rules.LoadBlock(this, d, s),

    CompleteStmt :n = walk:d walk:s                                                     -> this.rules.CompleteStmt(this, d, s),

    ErrorStmt    :n = walk:d walk:s                                                     -> this.rules.ErrorStmt(this, d, s),

    CancelStmt   :n = walk:d walk:s                                                     -> this.rules.CancelStmt(this, d, s),

    LoadStmt     :n = walk:d walk:s                                                     -> this.rules.LoadStmt(this, d, s),

    WatchStmt    :n = walk:d walk:s                                                     -> this.rules.WatchStmt(this, d, s),

    ActivityDef  :n = ?this.context.SetActivityCtx(n) walk:d walk*:h                   -> this.rules.ActivityDef(this, n.type(), h),

    SyncActivityDef  :n = ?this.context.SetActivityCtx(n) walk:d walk:s                -> this.rules.SyncActivityDef(this, n.type(), s)

}


JAMCTranslator.context = function() {

    var activityID = 0,
        inActivityFlag = false,
        activityCtx;

    return {
        Tracer: function(str) {
            console.log("======", str);
            return;
        },

        SetActivityCtx: function(q) {
            // TODO: Figure out how to generate trully random strings.
            activityID = Math.random().toString(36).substring(7);
            inActivityFlag = true;
            return true;
        },

        TarActivityCtx: function() {
            // Test and Reset Activity Context
            var flag = inActivityFlag;
            inActivityFlag = false;
            return flag;
        },

        GetActivityID: function() {
            return activityID;
        },

        SaveValToAC: function(val) {
            activityCtx = val;
        },

        GetValFromAC: function() {
            return activityCtx;
        },

        TestActivityCtx: function() {
            return inActivityFlag;
        }
    }
}();

JAMCTranslator.rules = {

    JDeclaration: function(that, sflag, tree, spec, decl, namespc) {
        console.log("jdec");
        var funcname = tree[1].name,
            params   = that.helpers.ParamsFromParamDecl(tree);

        that.context.SaveValToAC({
            sync: sflag,
            declspec: spec,
            fname: funcname,
            params: params,
            namespace: namespc
        });

        return sflag;
    },

    ODeclaration: function(that, otype, ret_type, params) {
        console.log("odec");
        return join(ret_type, ' ', otype, ' ', params);
    },

    // d is declarations within the compound statement
    // s is the set of statements
    CompoundStmt: function(that, d, s) {
        // console.log("compoundstmt");
        // var c_output = "";
        // var js_output = "";
        // var actx = that.context.GetValFromAC();
        // // create JavaScript wrapper
        // js_output += that.helpers.CreateJSWrapperFunction(that.context.GetActivityID(), actx.fname, actx.params);
        // // create C function - just need to revise the declaration.. rest is OK
        // c_output += that.helpers.CreateCFunction(actx.declspec, actx.fname, actx.params, join('{', d.join(''), s.join(''), '}'));

        // // register the C function callback
        // // c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "activity");

        // // Return object containing both C and JS components
        // return {
        //     C: c_output,
        //     JS: js_output
        // }
        return join('{', d.join(''), s.join(''), '}');
    },

    BlockStmt: function(that, cs) {
        // var c_output = "";
        // var js_output = "";
        // var actx = that.context.GetValFromAC();

        // // create JavaScript function - just need to change the function declaration from C to JS
        // js_output += that.helpers.CreateJSFunction(actx.fname, actx.params, join('{', cs.join(';'), '}'));

        // // create command hooking up JS function
        // js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "activity");
        
        // // create a C stub function.. brand new function.. this is called locally..
        // c_output += that.helpers.CreateCStubFunction(that.context.GetActivityID(), actx.declspec, actx.fname, actx.params);

        // return {
        //     C: c_output,
        //     JS: js_output
        // }
        return join('{', cs.join(';'), ';}');
    },

    LoadBlock: function(that, odecl, block) {
        var js_output = "",
            actx = that.context.GetValFromAC();
        // create the JavaScript function .. only C function declaration needs to change
        js_output += that.helpers.CreateJSFunction(actx.fname, "load", actx.params, block);

        // Register JS function use 'activityID', 'load', function
        js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "load");
        // return the code object..
        return {
            C: that.helpers.CreateCStubFunction(that.context.GetActivityID(), actx.declspec, actx.fname, "load", actx.params),
            JS: js_output
        }
    },


    CompleteBlock: function(that, odecl, block) {
        var js_output = "",
            actx = that.context.GetValFromAC();
        // create the JavaScript function .. only C function declaration needs to change
        js_output += that.helpers.CreateJSFunction(actx.fname, "complete", actx.params, block);

        // Register JS function use 'activityID', 'load', function
        js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "complete");
        // return the code object..
        return {
            C: that.helpers.CreateCStubFunction(that.context.GetActivityID(), actx.declspec, actx.fname, "complete", actx.params),
            JS: js_output
        }
    },

    ErrorBlock: function(that, odecl, block) {
        var js_output = "",
            actx = that.context.GetValFromAC();
        // create the JavaScript function .. only C function declaration needs to change
        js_output += that.helpers.CreateJSFunction(actx.fname, "error", actx.params, block);

        // Register JS function use 'activityID', 'load', function
        js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "error");
        // return the code object..
        return {
            C: that.helpers.CreateCStubFunction(that.context.GetActivityID(), actx.declspec, actx.fname, "error", actx.params),
            JS: js_output
        }
    },

    CompleteStmt: function(that, odecl, stmt) {
        var c_output = "",
            actx = that.context.GetValFromAC();
        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.declspec, actx.fname, "complete", actx.params, stmt);
        // register C function callback.. activityID, "load", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "complete");
        
        // return the code object..
        return {
            C: c_output,
            JS: that.helpers.CreateJSWrapperFunction(that.context.GetActivityID(), actx.fname, "complete", actx.params)
        }
    },

    ErrorStmt: function(that, odecl, stmt) {
        var c_output = "",
            actx = that.context.GetValFromAC();
        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.declspec, actx.fname, "error", actx.params, stmt);
        // register C function callback.. activityID, "load", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "error");
        
        // return the code object..
        return {
            C: c_output,
            JS: that.helpers.CreateJSWrapperFunction(that.context.GetActivityID(), actx.fname, "error", actx.params)
        }
    },

    CancelStmt: function(that, odecl, stmt) {
        var c_output = "",
            actx = that.context.GetValFromAC();
        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.declspec, actx.fname, "cancel", actx.params, stmt);
        // register C function callback.. activityID, "load", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "cancel");
        
        // return the code object..
        return {
            C: c_output,
            JS: that.helpers.CreateJSWrapperFunction(that.context.GetActivityID(), actx.fname, "cancel", actx.params)
        }
    },


    LoadStmt: function(that, odecl, stmt) {
        console.log("loadstmt");
        var c_output = "",
            actx = that.context.GetValFromAC();
        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.declspec, actx.fname, "load", actx.params, stmt);
        // register C function callback.. activityID, "load", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "load");
        
        // return the code object..
        return {
            C: c_output,
            JS: that.helpers.CreateJSWrapperFunction(that.context.GetActivityID(), actx.fname, "load", actx.params)
        }
    },


    WatchStmt: function(that, odecl, stmt) {
        var c_output = "",
            actx = that.context.GetValFromAC();
        // create the C function.. only slight revision of the function declarator
        c_output += that.helpers.CreateCFunction(actx.declspec, actx.fname, "watch", actx.params, stmt);
        // register C function callback.. activityID, "load", function
        c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "watch");
        
        // return the code object..
        return {
            C: c_output,
            JS: that.helpers.CreateJSWrapperFunction(that.context.GetActivityID(), actx.fname, "watch", actx.params)
        }
    },


    /** Activity matrix
     * C - sync     :   C statement, -, -, -, -
     * C - async    :   C statement, JS complete, JS error, C cancel, C verify
     * JS - sync    :   JS block, -, -, -, -
     * JS - async   :   JS block, C complete, C error, -, -
     */

    ActivityDef: function(that, atype, handlers) {
        console.log("act def", atype);
        // console.log(handlers);
        var actx = that.context.GetValFromAC();

        var handlerCount = [];
        handlerCount["CompleteBlock"] = 0;
        handlerCount["ErrorBlock"] = 0;
        handlerCount["LoadBlock"] = 0;
        handlerCount["CompleteStmt"] = 0;
        handlerCount["ErrorStmt"] = 0;
        handlerCount["CancelStmt"] = 0;
        handlerCount["LoadStmt"] = 0;
        handlerCount["WatchStmt"] = 0;

        for(i=0;i<handlers.length;i++) {
            handlerCount[handlers[i][0]]++
        }

        // Enforce consistency conditions.. c/js.. sync/async
        // Generate the code and return C/JS components of the generated source
        if (atype === 'c') {    // C - async
            return that.helpers.CreateOutput(handlers);
        } else if (atype == "js") {   // JS - async
            // that.helpers.AssertEmpty([cnclstmt], "Async JS activity cannot have a cancel or verify block");
            return that.helpers.CreateOutput(handlers);
        }
    },

    SyncActivityDef: function(that, atype, stmt) {
        var actx = that.context.GetValFromAC();
        c_output = "";
        js_output = "";
        if(atype == 'c') {
            // create JavaScript wrapper
            js_output += that.helpers.CreateJSWrapperFunction(that.context.GetActivityID(), actx.fname, "sync", actx.params);
            // create C function - just need to revise the declaration.. rest is OK
            c_output += that.helpers.CreateCFunction(actx.declspec, actx.fname, "sync", actx.params, stmt);

            // register the C function callback
            c_output += that.helpers.CreateCallBackHookUp(that.context.GetActivityID(), actx.fname, "sync");
        } else if (atype == 'js') {
            // create JavaScript function - just need to change the function declaration from C to JS
            js_output += that.helpers.CreateJSFunction(actx.fname, "sync", actx.params, stmt);
            
            // create command hooking up JS function
            js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "sync");
            
            // create a C stub function.. brand new function.. this is called locally..
            c_output += that.helpers.CreateCStubFunction(that.context.GetActivityID(), actx.declspec, actx.fname, "sync", actx.params);
        }
        return {
            C: c_output,
            JS: js_output
        }
    }
}


JAMCTranslator.helpers = {

    ParamsFromParamDecl: function(tree) {
        var i,
            tempdecs,
            tempdecl,
            collected = [];

        for (i = 2; i < tree.length; i++) {
            tempdecs = tree[i][2];
            tempdecl = tree[i][3];
            collected.push({name: tempdecl[1].name, pointer_level: tempdecl[1].pointer_level, type: tempdecs[2][1].type});
        }
        return collected;
    },

    /**
     * HookUp a C callback for the given activity - actID,
     * The C function name is given by - fname,
     * Name of the activity is given by - activity
     * Function "call" for inserting the callback is written here.
     */
    CreateCallBackHookUp: function(actID, fname, activity) {
        return join("registerCallBack(", actID, activity, fname, ");");
    },

    /**
     * Create a C function. Only the function declaration needs to be created.
     * The statement portion of the function is already there.
     * Function name is given by - fname
     * Function parameters given by - param
     * Statement block given by - stmt
     */
    CreateCFunction: function(dspec, fname, type, params, stmt) {
        var ps = [];
        params.forEach(function(p) {
            var ptrstr = "";
            for (var i = 0; i < p.pointer_level; i++)
                ptrstr += "*";
            ps.push([p.type, ptrstr, p.name].join(' '));
        });
        var a = join(dspec, ' ', fname, '_', type, '(', ps.join(','), ')', stmt);
        console.log("OUT: " +stmt);
        return a;
    },

    // create the JavaScript function .. only C function declaration needs to change
    // js_output += that.helpers.CreateJSFunction(actx.fname, actx.params, block);
    CreateJSFunction: function(fname, type, params, block) {
        var ps = [];
        params.forEach(function(p) {
            ps.push(p.name);
        });
        return join('function ', fname, '_', type, ' (', ps.join(','), ') ', block);
    },

    // Register JS function use 'activityID', 'error', function
    // js_output += that.helpers.CreateJSFunctionHookUp(that.context.GetActivityID(), actx.fname, actx.namespace, "error");
    CreateJSFunctionHookUp: function(actID, fname, type, namespace, activity) {
        return join("HookUpJSFunction(", actID, activity, fname, type, namespace, ");");
    },

    // create a C stub function.. brand new function.. this is called locally..
    CreateCStubFunction: function(actID, dspec, fname, type, params) {

        var ps = [], qs = [];
        params.forEach(function(p) {
            var ptrstr = "";
            for (var i = 0; i < p.pointer_level; i++)
                ptrstr += "*";
            ps.push([p.type, ptrstr, p.name].join(' '));
            qs.push(p.name);
        });
        var funccode = dspec + " " + fname + "_" + type + "(" + ps.join(', ') + ") {";

        // Write a C function to create JSON object with the parameters
        funccode += "JSONObj *j = jsoncreate(" + qs.join(', ') + ");";

        // Write a C function call to make the remote call with the JSON object
        funccode += "remotefunctioncall(" + actID + ", " + fname + ", " + "j);";

        // end
        funccode += "}";

        // return the string
        return funccode;
    },


    /**
     * This is a JS function wrapper to call a C function. Uses the same parameter names.
     * The JS function signature is slightly revised one of the C function without the type information.
     * Function name is given
     */
    // Create JavaScript wrapper
    CreateJSWrapperFunction: function(actID, fname, type, params) {
        var ps = [];
        params.forEach(function(p) {
            ps.push(p.name);
        });
        var funccode = "function " + fname + "_" + type + " (" + ps.join(',') + ") {";

        // write the code that would create the JSON object.
        funccode += "var jobject = {";
        var i = 0;
        params.forEach(function(p) {
            funccode += "arg" + (i++) + ":" + p.name + (i < params.length? "," : "");
        });
        funccode += "};";

        // write the code that would call the remote function
        funccode += "RemoteFunctionCall(" + actID + "," + fname + "_" + type + "," + "jobject" + ");";

        // write the end of the function
        funccode += "}";

        return funccode;
    },

    CreateOutput: function(arr) {
        var cout = "";
        var jsout = "";
        arr.forEach(function(e) {
            if (!!e.C)
                cout += e.C;
            if (!!e.JS)
                jsout += e.JS;
        });
        return {'C': cout, 'JS': jsout};
    },

    AssertEmpty: function(arr, msg) {
        for (var e in arr) {
            if (!!e.C || !!e.JS) {
                console.error(msg);
                // TODO: Need to exit..
            }
        }
    }
}


JAMCTranslator.force_rules = false;
JAMCTranslator.translate = function(input) {
    return JAMCTranslator.match(input, 'walk');
};

module.exports = JAMCTranslator;
